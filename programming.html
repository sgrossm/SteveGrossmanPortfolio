<!DOCTYPE HTML>
<html>
	<head>
		<title> Programming! </title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="icon" href="images/icon.png">
	</head>
	<body class="is-preload">

			<section id="header">
				<header>
					<h1 id="logo"><a href="index.html" class="fas fa-arrow-circle-left"> Steve Grossman</a></h1>
				</header>
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">Persistent Save and Load System</a></li>
						<li><a href="#two">Audio Manager</a></li>						
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/stevengrossman821/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://www.instagram.com/steviegrossman/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="https://www.youtube.com/channel/UC__D6CFUUO5ZA1of-vdP1iA" class="icon brands fa-youtube"><span class="label">Youtube</span></a></li>						
						<li><a href="mailto:stevegrossman821@gmail" class="icon solid fa-envelope"><span class="label">Email</span></a></li>
					</ul>
				</footer>
			</section>

			<div id="wrapper">			
							<section id="one">
								<div class="container">
									<h3> Save and Load System</h3>
									<div class="features">
										<article>
											<div>
												<h4>Preliminary data structures</h4>
												<p> The first step in designing this system is to pick a file format for your data. I chose
													json for a number of reasons. Unity supports json serialization and can convert generic collections
													such as Lists very easily. This means I can batch our save/load process to/from one object. The batching 
													becomes important when we start thinking about file IO. As long
													as fields are public and our class/struct is marked with [System.Serializable], we should be able to save them.
													(Okay, there are a few exceptions here: ScriptableObjects only serialize a reference and any nested Lists/Arrays or Dictionaries will need custom code).
													
													Firstly, each class with data fields that need to be saved will
													inherit a common interface, lets call it ISaveable. Each type of object will have a struct
													containing the relevant data fields that need to be saved (for example: CharacterData, AudioData, InventoryData, etc). These
													structs will similarly inherit from a common interface that will act as a tag, lets call it ISaveData.
													ISaveable will enforce two methods: PopulateSavedata and LoadFromSaveData, and each class will use these for their specific data.
													For our examples, I will use an example class called Character to save from and a struct called CharacterData to store fields. 

													Here is the code we need to get started. </p>
													
													
<pre><code>
ISaveable.cs

public interface ISaveable { 
	ISaveData PopulateSaveData();
	void LoadFromSaveData(ISaveData loadData);
}
</code></pre>

<pre><code>
ISaveData.cs

public interface ISaveData {} 
</code></pre>

<pre><code>
PlayableCharacterData.cs

[Serializable]
public struct PlayableCharacterData : ISaveData 
{
	public SerializableTransform SerializedTransform;
	public float Health;
	// more data fields to save/load
}

public static implicit operator PlayableCharacterData(Character currentCharacter)
{
	PlayableCharacterData player = new PlayableCharacterData {
		SerializedTransform = currentCharacter.transformRef,
		Health = currentCharacter.health
	};
	
	return player;
}
</code></pre>
													
													
												<h4> Saving </h4>
												<p>
													The process of collecting data will run as follows: <br/>
														1) Iterate through ISaveables currently active in the scene (see SaveComponent.cs below). <br/>
														2) Call PopulateSaveData() on each object.<br/>
														3) When done collecting the data, write it to the save file. <br/>
												</p>

<pre><code>
Character.cs

public class Character : ISaveable 
{
	// data fields, initialization, AI, etc 
	//...
	
	ISaveData PopulateSaveData()
	{
		PlayableCharacterData characterSave = this;
		return characterSave;
	}
	
	void LoadFromSaveData(ISaveData loadData)
	{
		var chardata = (PlayableCharacterData)loadData.=;
		transformRef = Deserialize(chardata.SerializedTransform);
		health = chardata.Health;
		// other fields to save
	}
	
}
</code></pre>
												
												
												<h4> Async File IO </h4> <p>
													A few notes about IO and game engines should be mentioned. File operations cannot block the main thread or stop
													gameplay if unsuccessful. In order to ensure this, we made our FileManger class operate using async/await methods. This 
													allowed us to run the IO without stopping execution and passing a Cancellation Token in case it hangs so we can cancel the operation 
													after a timeout is reached. </p>
<pre><code>
FileManager.cs

public class FileManager {
	public static async Task WriteToFile(string path, string data, CancellationToken timeout)
	{
		byte[] result = Encoding.ASCII.GetBytes(data);
		
		try {
			using (FileStream fileWriter = File.Open(path, FileMode.OpenOrCreate) ) {
				fileWriter.SetLength(0);
				fileWriter.Position = 0;
				await fileWriter.WriteAsync(result, 0, result.Length, timeout);

			}
		}
		
		catch (Exception e ) {
#if UNITY_EDITOR
			Debug.LogError($"Failed to write to {path} with exception {e.Message}");
#endif
		}
	}
}

public static async Task&ltstring&gt LoadFromFile(string FullPath, CancellationToken cancelToken)
{
	byte[] result;
	string fileOutput = "";

	try {
		using ( FileStream fileReader = File.Open(FullPath, FileMode.Open) ) {
			result = new byte[fileReader.Length];
			await fileReader.ReadAsync(result, 0, (int)fileReader.Length, cancelToken);
			fileOutput = Encoding.ASCII.GetString(result);
			return fileOutput;
		}
	}

	catch ( Exception e ) {
#if UNITY_EDITOR
		Debug.LogError($"Failed to read from {FullPath} with exception {e.Message}");
#endif
	}
	return fileOutput;
}

</code></pre>											
												<h4> Prefab IDs </h4><p>
													So far, we are able to collect data from objects in our scene and save their data to file. The next piece
													to consider, is that in order to pass a chunk of data back to the correct object, we need a data mapping schema.
													I decided to handle this issue by creating an ID for each Prefab during editor time. Each prefab that will 
													need to be saved will have a SaveComponent attached to it. </p>
<pre><code>
SaveComponent.cs

[Serializable]
public SaveComponent : MonoBehaviour {
	[SerializeField] private uint _prefabID;
	public uint PrefabID => _prefabID; 
	private bool NeedPrefabIDGenerated => this._prefabID == 0;

#if UNITY_EDITOR
	public static void InitSaveSystemPrefabIDs(string[] _folders) {
		string[] guids = AssetDatabase.FindAssets("t:Object", _folders);
            for ( int i = 0; i &lt guids.Length; ++i ) {
                string path = AssetDatabase.GUIDToAssetPath(guids[i]);
                SaveSystemComponent loadedObject = (SaveSystemComponent)AssetDatabase.LoadAssetAtPath(path, typeof(SaveSystemComponent));
                if ( loadedObject != null ) {
                    if ( loadedObject.NeedPrefabIDGenerated ) {
                        GeneratePrefabID(i, loadedObject);
                    }
                }
            }

	}
#endif

	private static void GeneratePrefabID(int i, SaveComponent componentID)
	{
		componentID._prefabID = Convert.ToUInt32(i + 1);
	}
}

</code></pre>
													<p>
													We iterate through the prefabs in our file system using the AssetDatabase and check to see if any prefabs do not have an ID component.
													We also need a data structure that contains all the prefabID:gameObject mappings. A ScriptableObject should work nicely,
													lets call it PrefabRegistrySO.
													We will need to manually add each GameObject prefab to our registry. Since we cannot serialize a Dictionary in the 
													Unity Inspector window, we use a list of GameObjects and create our Dictionary mapping at runtime.
													
													</p>
<pre><code>
PrefabRegistrySO.cs

    [CreateAssetMenu(fileName = "NewPrefabRegistry", menuName = "SaveSystem/PrefabRegistry")]
    public class PrefabRegistrySO : ScriptableObject {

        [SerializeField]
        public List&ltGameObject&gt ListOfSaveablePrefabs = new List&ltGameObject&gt();

        public static Dictionary&ltuint, GameObject&gt PrefabIDMapping = new Dictionary&ltuint, GameObject&gt();

        private void OnEnable()
        {
            ListToDictionary();
        }

        public void ListToDictionary()
        {
            for ( int i = 0; i &lt ListOfSaveablePrefabs.Count; ++i ) {
                GameObject prefabGameObject = ListOfSaveablePrefabs[i];
                SaveSystemComponent saveSystemUniqueID = prefabGameObject.GetComponent&ltSaveSystemComponent&gt();

                if ( saveSystemUniqueID == null ) {
#if DEBUG
                    Debug.LogError($"Object: {prefabGameObject.name} does not have a save component attached");
#endif
                    continue;
                }

                else if ( saveSystemUniqueID.PrefabID == 0 ) {
#if DEBUG
                    Debug.LogError($"Object: {prefabGameObject.name} does not have a unique Prefab ID");
#endif
                    continue;
                }

                else if ( !PrefabIDMapping.ContainsKey(saveSystemUniqueID.PrefabID) ) {
                    PrefabIDMapping.Add(saveSystemUniqueID.PrefabID, prefabGameObject);
                }
            }
        }
    }

</pre></code>
													
													The next hurdle is to think about how to design our system to be persistent between sessions. Luckily, our Prefab ID
													comes in handy for this issue as well. We can activate prefabs (using object pooling), based on their IDs
													and simply pass data back to each object.
													Now we will add a PersistentObject class to hold IDs and save data.
													and then call Save/Load on the SaveComponents themselves rather than in the Character class. 
													This decouples the actual saving and loading code from any specific game object or class and 
													abstracts it into a separate component. Here we are iterating through ISaveables and calling PopulateSaveData/LoadFromSaveData on each one.
<pre><code>
PersistentObject.cs

[Serializable]
public class PersistentObject {
	public uint PrefabID;
	public ISaveData[] saveDatas;
}
</pre></code>


<pre><code>
SaveComponent.cs 

public class SaveComponent {
	// Generate prefab ID
	// See above example 
	
	private ISaveable[] _saveables;
	
	private void Awake()
	{
		_saveables = GetComponents&ltISaveable&gt(); 
	}
	
	public ISaveData[] Save()
	{
		ISaveData[] saveDatas = new ISaveData[_saveables];
		ISaveable[] saveables = _saveables;
		
		for (int i = 0; i &lt saveables.Length; ++i)
		{
			var saveableInstance = saveables[i];
			saveDatas[i] = saveableInstance.PopulateSaveData(); 
		}
	}
	
	public void Load(PersistentObject saveData)
	{
		ISaveable[] saveables = _saveables;
	
		for (int i = 0; i &lt _saveables.Length; ++i)
		{
			var saveableInstance = saveables[i];
			saveableInstance.LoadFromSaveData()
		}
	}
}


</pre></code>
												<h4> Serialization </h4> <p>
													In order to use this system with all sorts of complex custom Unity objects
													I needed to forgo Unity's JsonUtility. I decided to use NewtonSoft JsonConvert instead as it allows for
													custom serialization and it performs TypeHandling out of the box. 
													And here is our Json handler which will take care of converting objects to json 
													during the save and converting strings to objects on load.
												</p>
			
<pre><code>			
JsonManager.cs

public class JsonHelper {
	public static string ConvertToJson(List&ltPersistentObject&gt data) {
		var settings = new JsonSerializerSettings() {
			TypeNameHandling = TypeNameHandling.All
		};
		
		return JsonConvert.SerializeObject(data, Formatting.Indented, settings);
	}
	
	public static List&ltPersistentObject&gt LoadFromJson(string jsonData, List&ltPersistentObject&lt data)
	{
		var settings = new JsonSerializerSettings() {
			TypeNameHandling = TypeNameHandling.All
		};
		
		return JsonConvert.DeserializeAnonymousType(jsonData, data, settings);
	}
}
</pre></code>											
													
													
												<h4> Loading </h4> <p>
													During load, we asynchronously read our json into the ISaveData[] chunk by chunk. Firstly, we need to release (deactivate) any ISaveable objects that are 
													currently active in the scene. Now instead of simply passing the data around, we will use object pooling here.
													The idea is that we can simply take the loaded ISaveData chunk, grab the PrefabID and reference the prefab ID in our PrefabRegistry
													to get back the prefab type that was saved. Our system activates this object and calls 
													ISaveable.Load(ISaveData data) to pass back the relevant data.
													
													Here is the Loading process step by step: <br/>
														1) Read from the save file into ISaveData[] (which is part of each PersistentObject) <br/>
														2) Release active ISaveable objects in scene <br/>
														3) Activate prefabs using object pool and prefab IDs from registry. <br/>
														4) Pass data back to object <br/>
													
													Lets see how all this works in tandem in the SaveManager class. </p>
<pre><code>
SaveManager.cs

public class SaveManager : MonoBehaviour {
	
	[SerializeField] private PrefabRegistrySO registry;
	[SerializeField] private List&ltPersistentObject&gt persistentData = new List&ltPersistenceObject&gt();
	
	private List&ltSaveComponent&gt _saveComponentList;
	private List&ltGameObject&gt _collectGameObjects;
	
	private void Awake()
	{
		_collectGameObjects = new List&ltGameObject&gt();
	}
	
	private void Start()
	{
		_saveComponentList = GetComponents&ltISaveable&gt(); 
	}

	private void CollectISaveables()
	{
		persistentData.Clear();
		Scene targetScene = SceneManager.GetActiveScene(); 
		CollectSaveDataFromScene(in targetScene);
	}
	
	private void CollectSaveDataFromScene(in Scene currentScene)
	{
		currentScene.GetRootGameObjects(_collectGameObjects);
		for (int i = 0; i &lt _collectGameObjects.Count; ++i)
		{
			GameObject gameObj = _collectGameObjects[i];
			SaveComponent saveComp = gameObj.GetComponent&ltSaveComponent&gt();
			if (gameObj.gameObject.activeSelf && saveComp != null)
			{
				CollectInstanceData(saveComp);
			}
		}
	}
	
	private void CollectInstanceData(SaveComponent saveComponent)
	{
		var persistentInstance = new PersistentObject {
			PrefabID = saveComponent.PrefabID,
			saveDatas = saveComponent.Save()
		};
		
		persistentData.Add(persistentInstance);
	}
	
	private void CreateSaveObjectPool(MemoryManager mem)
	{
		for (int i = 0; i &lt registry.Count; ++i)
		{
			mem.CreateNewPool(registry.ListOfSaveablePrefabs[i],
							registry.ListOfSaveablePrefabs[i].GetInstanceID(),
							new Pool {capacity = 10, length = 10}); 	// arbitrary size
		}
	}
	
	private InstantiateLoadData()
	{
		ClearActiveSaveObjectsBeforeLoad();
			
		for (int i = 0; i &lt persistentData.Count; ++i)
		{
			PersistentObject persistentObject = persistentData[i];
			uint savedPrefabID = persistentObject.prefabID;
			
			if (PrefabRegistrySO.PrefabIDMapping.ContainsKey(savedPrefabID))
			{
				GameObject objectToInstantiate = PrefabRegistry.PrefabIDMapping[savedPrefabID];
				var saveComponent = MemoryManager.GetInstanceOf(objectToInstantiate);
				saveComponent.Load(persistentObject);
			}
		}		
	}
	
	private void ClearActiveSaveObjectsBeforeLoad()
	{
		for (int i = 0; i &lt _saveComponentList.Count; ++i)
		{
			uint prefabID = _saveComponentList[i].PrefabID;
			GameObject prefab = PrefabRegistrySO.PrefabIDMapping[uid];
			var instance = _saveComponentList[i];
			MemoryManager.ReleaseInstanceOf(prefab, instance);
		}
	}
	
	private async Task WriteAllToFile()
	{
		CancellationTokenSource cts = new CancellationTokenSource();
		cts.CancelAfter(30000);
		await FileManager.WriteToFile(Application.persistentDataPath,
					JsonManager.ConvertToJson(persistentData),
					cts.Token);
		cts.Dispose();
	}
						
	
	private async Task ReadFromFile()
	{
		persistentData.Clear();
		CancellationTokenSource cts = new CancellationTokenSource();
		cts.CancelAfter(3000);
		string fileOutput = await FileManager.LoadFromFile(Application.persistentDataPath,
					cts.Token);
		persistentData = JsonManager.LoadFfromJson(fileOutput, persistentData);
		cts.Dispose();
		InstantiateLoadData();
	}
}

</pre></code>
													I've left some things out for brevity, mainly the object pooling details and read/write IO events triggered from the UI,
													but you can fill in those gaps as a fun challenge. 
													
													
													
													The beauty of this design is that it abstracts the system so it can save/load from different events such as New Game, death, etc.
													This means any object that needs to restore or capture the game state will be able to do so by using this system. 
													
													Now this code is by no means perfectly optimized. I am iterating through everything in the scene and reloading it,
													even if the saved data is no different from the current default data. A more intelligent design would be to cache only the new 
													data and reload objects that have changed since the last save. Caching is possible with our current system and 
													would greatly reduce loading times, especially as the size of our levels grow. Currently, I have not had the resources to implement 
													this optimization yet, but stay tuned in the future for any updates!
													</p>
											</div>
										</article>
									</div>
								</div>
							</section>
							<hr/>
							<section id="two">
								<div class="container">
									<h3>Audio Implementation with FMOD</h3>
									<div class="features">
										<article>
											<div>
												<h4>Fmod Unity Integration basics </h4>
												<p>
													The first step here was to understand how the FMOD Unity integration needs to be set up.
													Firstly, the main camera needs to have a Studio Listner object attached. With only one camera, this is quite simple.
													Next, we need to decide which banks need to be loaded using a Studio Bank Loader component. Now we are ready to connect our events. 
													
													At this point, it is important to note that the FMOD Unity integration works by using string references. 
													This is true for all functions referencing events, parameters, busses, and banks. The problem with that, 
													is that string comparisons are extremely slow and unreliable. What happens if we change the name? We need to track down a missing 
													reference. Instead, there is an option in FMOD to export a C# file with GUIDs. The GUID won't change even if the name does.
													On the top row of options, go to Scripts/FMOD Examples/Export GUIDS Header/C# File.
													GUIDs is how FMOD references everything on the backend and using them directly will speed things up a bit. 
<pre><code>
FMODReferences.cs

using System;

namespace FSPRO
{
    public class Event
    {
        public static readonly Guid Events_Music_Music = new Guid(0x3d2ed972, 0x4e06, 0x43e9, 0xad, 0x29, 0x01, 0x22, 0xda, 0x3a, 0x72, 0x0e);
        public static readonly Guid Events_SFX_Character_EmoteJump = new Guid(0x270aae82, 0x32a8, 0x45d6, 0xa7, 0xcb, 0xdf, 0x90, 0x6f, 0xd4, 0x46, 0x2a);
        public static readonly Guid Events_SFX_Character_EmoteLand = new Guid(0x7e4bb059, 0xd1d1, 0x4170, 0xb5, 0x15, 0x88, 0xc8, 0x94, 0x04, 0x7d, 0x1f);
        public static readonly Guid Events_SFX_Character_EmoteSwing = new Guid(0x1af2c91d, 0x1453, 0x4196, 0x9c, 0x12, 0x32, 0xbf, 0x4f, 0x01, 0x98, 0x09);
        public static readonly Guid Events_SFX_Character_Footsteps = new Guid(0xe6f36b30, 0xcc34, 0x4bcd, 0xab, 0x15, 0x7e, 0xca, 0x9a, 0xb2, 0xe9, 0xc0);
        public static readonly Guid Events_SFX_Character_Jump = new Guid(0x543d1350, 0xf8b2, 0x44d4, 0xa1, 0x18, 0xcb, 0xee, 0xc9, 0xe5, 0x4c, 0xdb);
		// ... more events
	}
	
	public class Bus
	{
		// Bus GUIDs
	}
	
	public class Bank 
	{
		// Bank GUIDs
	}
}
</code></pre>
													<h4> AudioManager </h4>
													After setting up a basic FMOD project with a couple standard events containing simple parameters, I assigned them to 
													mixer busses and built them to bank files located in the Unity project Assets folder.
													
													I then created an empty Unity object called AudioManager and started organizing this system.
													Firstly, I split events into three general categories: Music, SFX, and Ambience.
													
													This allowed me to segrate the system based on the type of audio and context of when it should be playing.
													Here is what my audio manager script looks like:
<pre><code>
AudioManager.cs 

public class AudioManager {
	public EventInstance EventInstance;

	public EventInstance CreateEvent(Guid eventGuid)
	{
		EventInstance eInst = RuntimeManager.CreateInstance(eventGuid);
		return eInst;
	}

	public void CreateAndStartEvent(Guid eventGuid)
	{
		EventInstance = RuntimeManager.CreateInstance(eventGuid);
		EventInstance.start();
		EventInstance.release();
	}

	public void StopEvent(STOP_MODE stopMode)
	{
		EventInstance.stop(stopMode);
	}

	public bool isVoiceVirtual()
	{
		EventInstance.isVirtual(out bool virt);
		return virt;
	}

	public PARAMETER_ID GetParameterID(string parameterName)
	{
		PARAMETER_ID parameterID;
		EventDescription eventDesc;
		EventInstance.getDescription(out eventDesc);
		PARAMETER_DESCRIPTION parameterDescription;
		eventDesc.getParameterDescriptionByName(parameterName, out parameterDescription);
		parameterID = parameterDescription.id;
		return parameterID;
	}

	public void PlayOneShotAttached(Guid eventGuid, GameObject obj, string parameterName, float value)
	{
		RuntimeManager.PlayOneShotAttached(eventGuid, obj, parameterName, value);
	}

	public static void SetBusVolume(string busPath, float volume)
	{
		Bus busName = RuntimeManager.GetBus(busPath);
		busName.setVolume(volume);
	}

	public static float GetBusVolume(string busPath)
	{
		float vol = 0f;
		Bus busName = RuntimeManager.GetBus(busPath);
		busName.getVolume(out vol);
		return vol;
	}
}
</code></pre>												
													Lets break down a little bit of what's going on here. 
													
													Now I am able to play sound from anywhere in the project without duplicating code. This also allow non audio programmers
													to use the code without needing to understand the backend. They just need to include an AudioManager object in their class. 
													
													Another interesting fact, is that we have the ability to reference parameters by name(string), which is very slow,
													or by ID which is only a single integer comparison rather than a bunch of character comparisons.													
													
													
													SFX, for the most part, were attached to Character objects and needed to be 3D. The footsteps audio, for instance,
													needed to be attached to the Character feet (this is a third-person game), so the sound is coming from under
													the camera. The function we want to call in this case is RuntimeManager.PlayOneShotAttached which fires off a
													single instance sound and allows you to pass in a GameObject. The native function does not allow you to pass in a parameter for the event. 
													Luckily, we have access to the FMOD source code and can easily override the PlayOneShotAttached to include this.
<pre><code>
public static void PlayOneShotAttached(Guid guid, GameObject gameObject, string parameterName, float parameterValue)
{
	var instance = CreateInstance(guid);
	AttachInstanceToGameObject(instance, GameObject.transform, gameObject.GetComponent&ltRigidbody&gt());
	instance.SetParameterByName(parameterName, parameterValue);
	instance.start();
	instance.release();
}

</code></pre>																							
													
													Then, using TerrainData and SplatMaps, I was able to get the floor material type (wood/sand/grass)
													and play the relevant Multi-Instrument samples depending on which index value is returned, using FMOD parameters.
<pre><code>
TerrainDetector.cs

public class TerrainDetector : MonoBehaviour {

	private TerrainData _terrainData;
	private int _alphamapWidth;
	private int _alphamapHeight;
	private float[,,] _splatMapData;
	private int _numTextures;

	public TerrainDetector()
	{
		_terrainData = Terrain.activeTerrain.terrainData;
		_alphamapWidth = _terrainData.alphamapWidth;
		_alphamapHeight = _terrainData.alphamapHeight;

		_splatMapData = _terrainData.GetAlphamaps(0, 0, _alphamapWidth, _alphamapHeight);
		_numTextures = _splatMapData.Length / (_alphamapWidth * _alphamapHeight);
	}

	private Vector3 ConvertToSplatMapCoordinate(Vector3 worldPosition)
	{
		Vector3 splatPosition = new Vector3();
		Terrain terrain = Terrain.activeTerrain;
		Vector3 terrainPosition = terrain.transform.position;
		splatPosition.x = ((worldPosition.x - terrainPosition.x) / terrain.terrainData.size.x) * terrain.terrainData.alphamapWidth;
		splatPosition.z = ((worldPosition.z - terrainPosition.z) / terrain.terrainData.size.z) * terrain.terrainData.alphamapHeight;
		return splatPosition;
	}

	public int GetActiveTerrainTextureIndex(Vector3 position)
	{
		int activeTerrainIndex = 0;
		float largestOpacity = 0f;
		Vector3 terrainCoord = ConvertToSplatMapCoordinate(position);

		for ( int i = 0; i &lt _numTextures; ++i ) {
			if ( largestOpacity &lt _splatMapData[(int)terrainCoord.z, (int)terrainCoord.x, i] ) {
				activeTerrainIndex = i;
				largestOpacity = _splatMapData[(int)terrainCoord.z, (int)terrainCoord.x, i];
			}
		}

		return activeTerrainIndex;
	}
}
</pre></code>
												<p> Then, I attached the PlayOneFootstep() function below to the animation event 
												where the character's foot hits the ground for walking, running, etc. </p>
<pre><code>
Footsteps.cs

public class Footsteps : MonoBehaviour {
	[SerializeField] private GameObject shoes;
	[SerializeField] private GameObject mainCamera;
	[SerializeField] private int listener = 0;
	private TerrainDetector terrainDetector;
	private AudioManager _audioManager;

	FMOD.ATTRIBUTES_3D positionSettings = new FMOD.ATTRIBUTES_3D();
	FMOD.VECTOR playerPosition;

	private void Awake()
	{
		terrainDetector = new TerrainDetector();
		_audioManager = new AudioManager();
	}

	private void Update()
	{
		positionSettings.position = RuntimeUtils.ToFMODVector(mainCamera.transform.position);
		playerPosition = RuntimeUtils.ToFMODVector(shoes.transform.position);

		RuntimeManager.StudioSystem.setListenerAttributes(listener, positionSettings, playerPosition);
	}

	public void PlayOneFootstep()
	{
		int terrainTextureIndex = terrainDetector.GetActiveTerrainTextureIndex(transform.position);
		_audioManager.PlayOneShotAttached(FmodEventGuids.Events_SFX_Character_Footsteps, gameObject,
										  FmodParameters.Parameter_Character_FloorMaterial, terrainTextureIndex);
	}
}
</pre></code>


													Now that I have explained the types of events, it will be useful to give some examples of parameters that 
													are used to modify playback and introduce variation depending on gameplay context.
													
													One of the quirks of the FMOD Unity integration is that global parameters don't always work as expected. 
													Oftentimes, they don't even show up as options in the editor (the only time they do is if they are continuous 
													parameters, but they don't appear for discrete/labeled parameters). One of the examples of a global parameter 
													I needed to refer to was the "GamePaused" parameter that added a bandpass filter onto the current music playing
													while the game was paused. I wanted each music event to share this parameter to avoid duplicating behaviour.
													After some research, here is the background music script I came up with: 
<pre><code>
BackgroundMusic.cs

public class BackgroundMusic : MonoBehaviour {
	private AudioManager _audioManager = new AudioManager();
	private EventInstance _backgroundMusicEvent;
	private PARAMETER_ID _musicParameterID;

	private void Start()
	{
		_audioManager.CreateAndStartEvent(FmodEventGuids.Events_Music_ExploreIsland);

	}

	private void Update()
	{
		_musicParameterID = _audioManager.GetParameterID(FmodParameters.GlobalParameter_Music_GamePaused);
		RuntimeManager.StudioSystem.setParameterByID(_musicParameterID, Convert.ToInt32(GameManager.Instance.GameIsPaused));
	}

	private void OnDestroy()
	{
		_audioManager.StopEvent(STOP_MODE.ALLOWFADEOUT);
	}
}
</code></pre>										
													
													<br/>
													
												</p>
											</div>
										</article>
									</div>
								</div>
							</section>
							<hr/>
					</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
